#![allow(dead_code)]

extern crate spidev;

pub mod error_codes;
pub use error_codes::*;
pub mod types;
pub use types::*;
pub mod bindings; // Autogenerated Bindings
pub mod leptonspi;
pub use leptonspi::*;
#[cfg(test)]
mod tests;

/// An opaque version of `LEP_CAMERA_PORT_DESC_T_TAG`
#[repr(C)]
#[derive(Debug, Clone)]
pub struct CameraPortDescriptor {
    inner: bindings::LEP_CAMERA_PORT_DESC_T_TAG,
    opened: bool
}

impl CameraPortDescriptor {

    /// 1 for `/dev/i2c-1`, 0 for `/dev/i2c-0`
    pub fn new(port_id: u16) -> CameraPortDescriptor {
        CameraPortDescriptor {
            inner: bindings::LEP_CAMERA_PORT_DESC_T_TAG {
                portID: port_id,
                portType: PortTag::CciTwi as u32,
                portBaudRate: 400, // kHz
                deviceAddress: 0x2A,
            },
            opened: false,
        }
    }

    /// return a raw pointer to the inner `LEP_CAMERA_PORT_DESC_T_TAG`
    pub unsafe fn inner_ptr(&mut self) -> *mut bindings::LEP_CAMERA_PORT_DESC_T_TAG {
        &mut self.inner as *mut bindings::LEP_CAMERA_PORT_DESC_T_TAG
    }


    /// Open the I2C port
    pub fn open(&mut self) -> LeptonResult {
        use bindings::*;

        let result;
        unsafe {
            result = LEP_OpenPort(self.inner.portID,
                                  self.inner.portType,
                                  self.inner.portBaudRate,
                                  self.inner_ptr()
                                  ).into();
        }

        if result == LeptonResult::Ok {
            self.opened = true;
        }
        result
    }

    /// Close the I2C port
    pub fn close(&mut self) -> LeptonResult {
        use bindings::*;

        self.check_open();
        unsafe {
            LEP_ClosePort(self.inner_ptr()).into()
        }
    }


    /// Enable radiometric mode
    pub fn enable_radiometry(&mut self) -> LeptonResult {
        use bindings::*;

        self.check_open();
        unsafe {
            LEP_SetRadEnableState(self.inner_ptr(), EnableState::Enabled as u32).into()
        }
    }


    /// Run a reboot of the camera. Useful if data isn't synced
    pub fn restart(&mut self) -> LeptonResult {
        use bindings::*;

        self.check_open();
        unsafe {
            LEP_RunOemReboot(self.inner_ptr()).into()
        }
    }


    /// Run a flat-field correction
    pub fn do_ffc(&mut self) -> LeptonResult {
        use bindings::*;

        self.check_open();
        unsafe {
            LEP_RunSysFFCNormalization(self.inner_ptr()).into()
        }
    }


    /// Warn if the camera hasn't been opened
    pub fn check_open(&mut self) {
        if !self.opened {
            if self.open().is_err() {
                eprintln!("[warning] Lepton i2c port not opened!")
            }
        }
    }

}

impl Drop for CameraPortDescriptor {
    /// Automatically close the port when the struct goes out of scope
    fn drop(&mut self) {
        self.close();
    }
}
